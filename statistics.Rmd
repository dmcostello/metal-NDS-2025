---
title: "TRACE NDS code for statistical analysis"
author: "Dave Costello"
date: "2025-09-26"
output: html_document
---

```{r setup, include=FALSE}
require(dplyr)
require(randomForest)
require(caret)
```

### Load data

```{r load site data}
sites <- read.csv(file="./raw data/NDSsites.csv")
summary(factor(sites$Problem)) #60 total NDS deployments were done, 9 duplicates
unique(sites$Stream) #52 unique streams where NDS were deployed
unique(sites[sites$Problem=="None",'Stream']) #41 streams were NDS were successfully retrieved

#Streams with good NDS deployments by year
goodNDS <- sites[sites$Problem=="None",]
good21 <- goodNDS[goodNDS$Year==2021,'Stream']
good22 <- goodNDS[goodNDS$Year==2022,'Stream']
```

```{r load biomass data}
chl <- read.csv(file="./raw data/chlorophyll.csv") #Lab measured chla
BT <- read.csv(file="./raw data/benthotorch.csv") #Field fluorometry

all_algae <- merge(chl[,c(2:3,5)],BT,by=c("Sample_ID","Year"),all=T) #Combined
```

```{r load environmental data}
WQ_NDS <- read.csv(file="./raw data/WQ.csv") #Water quality samples

LULC <- read.csv(file="./raw data/LULC.csv") #Land use land cover data

NDSsoil <- read.csv(file="./raw data/soilmetalWS.csv") #Metal in soils data

#Make merged dataset - 41 streams, 99 predictors
land <- merge(LULC,NDSsoil[,c(2,4:24)],by="Stream")
landWQ <- merge(land,WQ_NDS,by.x="Stream",by.y="Site")
```

```{r load derived data}
#Classification based on presence/absence of N, P, Fe, Zn limitation
bclass <- read.csv("./derived data/classify.csv")

#Merge with site info
siteclass <- merge(sites[sites$Problem=="None",],bclass,by.x="Stream",by.y="Site",all.x=T)

#Merge classification with environmental predictors
predclass <- merge(bclass,landWQ,by.x="Site",by.y="Stream",all=T) 
```


### Calculate log response ratios and nutrient limitation classification

Calculating response ratios using the method of Harpole et al. 2011.

Harpole, W. Stanley, et al. "Nutrient coâ€limitation of primary producer communities." *Ecology Letters* 14.9 (2011): 852-862.

Note that 2021 and 2022 had different treatment combinations so the RRs are not identical across years.

```{r RR calcs}
 #Redefine for different endpoints
dataforRR <- BT #name of dataset with raw biomass data
RRvar <- "Diatoms" #Column name for which to calculate response ratios

  #Subsets data into different years 
RR21data <- dataforRR[dataforRR$Year==2021,]
RR22data <- dataforRR[dataforRR$Year==2022,]

  #Create empty dataframes to store response ratios
RR21 <- data.frame("Site"=good21)
RR22 <- data.frame("Site"=good22)
  
  #Function to calculate treatment means and response ratios from 2021 
for(i in 1:length(good21)){
  sub <- RR21data[RR21data$Site==good21[i],]
  means <- with(sub,tapply(sub[,which(colnames(sub)==RRvar)], #Use  to find column matching variable name
                           Treatment,mean,na.rm=T))
  
    #Single element response ratios
RR21[RR21$Site==good21[i],'Control'] <-means[1]
RR21[RR21$Site==good21[i],'N'] <-log(means[2]/means[1])
RR21[RR21$Site==good21[i],'P'] <-log(means[3]/means[1])
RR21[RR21$Site==good21[i],'Fe'] <-log(means[4]/means[1])
RR21[RR21$Site==good21[i],'Zn'] <-log(means[5]/means[1])

  #Multi-element log response ratios (for plots)
RR21[RR21$Site==good21[i],'NP'] <-log(means[10]/means[1])
RR21[RR21$Site==good21[i],'PFe'] <-log(means[6]/means[1])
RR21[RR21$Site==good21[i],'PFeMo'] <-log(means[7]/means[1])
RR21[RR21$Site==good21[i],'PFeNi'] <-log(means[8]/means[1])
RR21[RR21$Site==good21[i],'NFeZn'] <-log(means[9]/means[1])
RR21[RR21$Site==good21[i],'NFe'] <- log((means[2]+means[4]-means[1])/means[1]) 

#Assume N+Fe was additive. In 2022 everything was either sub-additive or antagonistic so this is the more conservative estimate. Not used for plotting, but used for calculating interation response ratios
RR21[RR21$Site==good21[i],'NPFe'] <-log(means[11]/means[1])

#Interaction response ratio calculations
RR21[RR21$Site==good21[i],'NxP'] <- ((means[1]+means[10])-(means[2]+means[3]))/means[1]
#NPFe compared NPFe combination to additive of NP and Fe
RR21[RR21$Site==good21[i],'NPxFe'] <- ((means[1]+means[11])-(means[4]+means[10]))/means[1]
#PFe compares P+Fe to additive Fe and P
RR21[RR21$Site==good21[i],'PxFe'] <- ((means[1]+means[6])-(means[3]+means[4]))/means[1]

#Mo and Ni compare 3-element combination to FeP
RR21[RR21$Site==good21[i],'Mo'] <- (means[7]-means[6])/means[1]
RR21[RR21$Site==good21[i],'Ni'] <- (means[8]-means[6])/means[1]

#Missing N+Fe treatment to compare like Mo and Ni. Assume additive N and Fe and compare additive N, Fe, and Zn to N+Fe+Zn combination. Had to add 2 controls to N+Fe+Zn to account for three treatments
RR21[RR21$Site==good21[i],'NFexZn'] <- ((means[9]+2*means[1])-(means[2]+means[4]+means[5]))/means[1]
}

  #Function to calculate treatment means and response ratios from 2022
for(i in 1:length(good22)){
  sub <- RR22data[RR22data$Site==good22[i],]
  means <- with(sub,tapply(sub[,which(colnames(sub)==RRvar)],Treatment,mean,na.rm=T))
  
    #Single element response ratios
RR22[RR22$Site==good22[i],'Control'] <-means[1]
RR22[RR22$Site==good22[i],'N'] <-log(means[2]/means[1])
RR22[RR22$Site==good22[i],'P'] <-log(means[3]/means[1])
RR22[RR22$Site==good22[i],'Fe'] <-log(means[4]/means[1])
RR22[RR22$Site==good22[i],'Zn'] <-log(means[5]/means[1])

  #Multi-element log response ratios (for plots)
RR22[RR22$Site==good22[i],'NP'] <-log(means[11]/means[1])
RR22[RR22$Site==good22[i],'NPFe'] <-log(means[12]/means[1])
RR22[RR22$Site==good22[i],'PFe'] <-log(means[6]/means[1])
RR22[RR22$Site==good22[i],'PFeMo'] <-log(means[8]/means[1])
RR22[RR22$Site==good22[i],'PFeNi'] <-log(means[9]/means[1])
RR22[RR22$Site==good22[i],'NFe'] <-log(means[7]/means[1])
RR22[RR22$Site==good22[i],'NFeZn'] <-log(means[10]/means[1])


#Interaction response ratio calculations
RR22[RR22$Site==good22[i],'NxP'] <- ((means[1]+means[11])-(means[2]+means[3]))/means[1]
#NPFe compared NPFe combination to additive of NP and Fe
RR22[RR22$Site==good22[i],'NPxFe'] <- ((means[1]+means[12])-(means[4]+means[11]))/means[1]
#PFe compares P+Fe to additive Fe and P
RR22[RR22$Site==good22[i],'PxFe'] <- ((means[1]+means[6])-(means[3]+means[4]))/means[1]
#NFe compares N+Fe to additive Fe and N
RR22[RR22$Site==good22[i],'NxFe'] <- ((means[1]+means[7])-(means[2]+means[4]))/means[1]
#Zn compares N+Fe+Zn to additive Zn and N+Fe
RR22[RR22$Site==good22[i],'NFexZn'] <- ((means[1]+means[10])-(means[5]+means[7]))/means[1]

#Mo and Ni compare 3-element combination to FeP. 
RR22[RR22$Site==good22[i],'Mo'] <- (means[8]-means[6])/means[1]
RR22[RR22$Site==good22[i],'Ni'] <- (means[9]-means[6])/means[1]
}

#Show results
head(RR22)

```

This code uses response ratios for treatments and classifies into 1 of 13 possible response classes (e.g., sub-additive, serial A:B). See Figure S2 for classification schema.

```{r classification}
#Co-limitation classification functions
#Provide the dataset, the logRR of the individual treatments (e.g., A & B) and the interaction RR (AxB)

#This function is for fully-crossed combinations (i.e., you have response ratios for A, B, and AxB)
lim_class <- function(A,B,AxB,dataset){
  forlen <- dim(dataset)[1]
  sub <- (dataset[,c(A,B,AxB)])
  tempvec <- rep("Unclassified",length=forlen)
  for(i in 1:forlen){
    tempvec[i] <- 
      if(sum(is.na(sub[i,]))>0){NA} else #If any values are NA cannot calculate
      if(sub[i,1]>0.325){ #If growth response to A
        
        if(sub[i,2]>0.325) { #And growth response to B then all Independent co-limited
          if(sub[i,3]>0.385) {"Ind sup"} else #Super-additive
            if(sub[i,3]< -0.385) {"Ind sub"} else #Sub-additive
            {"Ind add"} #Additive
        } 
        else #If no growth response to B
          if(sub[i,3]>0.385) {paste("Serial",A,":",B)} else #Serial limitation
            if(sub[i,3]< -0.385) {paste("Antag",B)} else
            {paste("Single",A)}
      } #End of A limited

    else #If no growth response to A
        if(sub[i,2]>0.325){ #But a growth response to B
          if(sub[i,3]>0.385){paste("Serial",B,":",A)} else #Serial limitation
            if(sub[i,3]< -0.385) {paste("Antag",A)} else
            {paste("Single",B)}
        } 
          
    else #No growth to A or B
      if(sub[i,1]> -0.325&sub[i,2]> -0.325){ #No negative responses
        if(sub[i,3]>0.385){"Simult"} else
          if(sub[i,3]< -0.385) {"Neg"} else
            {"No lim"}
          }
            else #Some negative responses
            if(sub[i,3]>0.385){"Rescue"} else
            {"Neg"}
    
          }
      print(tempvec)
      }

#This function is for incomplete combinations (i.e., you have response ratios for A and AxB). This is specific for Ni and Mo (all years) and Zn in 2021

lim_class2 <- function(A,AxB,dataset){
  forlen <- dim(dataset)[1]
  sub <- (dataset[,c(A,AxB)])
  tempvec <- rep("Unclassified",length=forlen)
  for(i in 1:forlen){
    tempvec[i] <- 
      if(sum(is.na(sub[i,]))>0){NA} else #If any values are NA cannot calculate
      
        if(sub[i,1]>0.325){ #If growth response to A
          if(sub[i,2]>0.385) {"Ind"} else #Independent co-limitation (or serial)
            if(sub[i,2]< -0.385) {paste("Antag",AxB)} else #Antag
            {paste("Single",A)} #Single element limited
          
        } else #If no growth response to A
        {if(sub[i,2]>0.385){"Simult"} else #Simultaneous limitation
            if(sub[i,2]< -0.385) {"Neg"} else
            {"No lim"}
        }
      }
      print(tempvec)
}

#Test it
lim_class("N","P","NxP",RR22) %>% table()
lim_class2("PFe","Mo",RR22) %>% table()
```

This code was used to create derived files `RR_chl.csv`, `RR_BT.csv`, `RR_chl_diatom.csv`, `RR_cyano.csv`, and `RR_chlorophyte.csv`. The derived file `classify.csv` is a version of these files where classification of nutrient (co-)limitation is reduced to presence/absence.

### Random forest models
Build test and train datasets. Used the same streams in test/train datasets for all response variables. To be representative, we targeted a test dataset with 3/4 sites N limited, 1/2 P limited, 1/2 Fe limited, and 1/4 Zn limited. We also wanted a test dataset that was regionally representative.

```{r test and train data}
set.seed(13)
test <- sample(1:40,8)
test[8] <- 36 #Swap out the 3rd NEO for another random UP site
predclass[test,1:6]
```

Here is example code for the process of optimization of hyperparameters `mtry`, `maxnodes`, and  `ntrees` for the Fe limitation RF model. Optimization was done independently for each response variable using the full dataset.

```{r hyperparameter optimization}
#Build dataset
tunedata <- cbind(resp=as.factor(predclass[,3]),na.roughfix(predclass[,c(2,10:108)]))

## Define repeated cross validation with 5 folds and 10 repeats
cv10 <- trainControl(method='repeatedcv', number=5, repeats=10)

## Tune mtry
tuneGrid <- expand.grid(.mtry = seq(10,100,by=5))

set.seed(8)

#Grid search for best # of variables per tree
rf_mtry <- train(resp~.,data=tunedata, 
        method='rf', trControl=cv10,
        metric='Accuracy',
        tuneGrid = tuneGrid)

print(rf_mtry)
best_mtry <- rf_mtry$bestTune$mtry 
  # 100 variables tried

#Tune maxnodes
store_maxnode <- list()
tuneGrid <- expand.grid(.mtry = best_mtry)

for (maxnodes in c(2:5)) {
    set.seed(1234)
    rf_maxnode <- train(resp~.,
        data = tunedata,
        method = "rf",
        metric = "Accuracy",
        tuneGrid = tuneGrid,
        trControl = cv10,
        importance = TRUE,
        maxnodes = maxnodes,
        ntree = 300)
    current_iteration <- toString(maxnodes)
    store_maxnode[[current_iteration]] <- rf_maxnode
}
results_maxnode <- resamples(store_maxnode)
summary(results_maxnode)
  # 4 nodes (maximum Q3 without negative min)

#Tune number of trees 
store_ntree <- list()
for (ntree in seq(400,2000,by=100)) {
    set.seed(1234)
    rf_maxtree <- train(resp~.,
        data = tunedata,
        method = "rf",
        metric = "Accuracy",
        tuneGrid = tuneGrid,
        trControl = cv10,
        importance = TRUE,
        maxnodes = 2,
        ntree = ntree)
    current_iteration <- toString(ntree)
    store_ntree[[current_iteration]] <- rf_maxtree
}
results_ntree <- resamples(store_ntree)
summary(results_ntree)
  # 500 trees
```

```{r iron random forest model}
#Build Fe dataset
rfFedata <- cbind(Fe_TF=as.factor(predclass[,'Fe_TF']),na.roughfix(predclass[,c(2,10:108)]))

#Invert the response variables to put YES limited first
rfFedata$Fe_TF <- factor(rfFedata$Fe_TF,levels=c("Yes","No"))

#Test and train subsets
Fetrain <- rfFedata[-test,]
Fetest <- rfFedata[test,]

#Run rf model and evaluate performance (33% misclass)
set.seed(18)
rfFe <- randomForest(Fe_TF~.,
    data=Fetrain,mtry=100,maxnodes=4,ntree=500)
rfFe

#Test data 75% accuracy (2 of 8 misclassified)
testpred <- predict(rfFe,newdata = Fetest)
confusionMatrix(testpred, Fetest$Fe_TF)

#Partial dependence plots for top variables
varImpPlot(rfFe,n.var = 10)

partialPlot(rfFe,rfFedata,INORGNWETDEP2008WS,"Yes",n.pt=100)
partialPlot(rfFe,rfFedata,SRP_ugL,"Yes",log="x",n.pt=100)

#save(rfFe,file="rfFe.Rdata")
```

```{r nitrogen random forest model}
#Build N dataset
rfNdata <- cbind(N_TF=as.factor(predclass[,'N_TF']),na.roughfix(predclass[,c(2,10:108)]))

#Invert the response variables to put YES limited first
rfNdata$N_TF <- factor(rfNdata$N_TF,levels=c("Yes","No"))

#Test and train subsets
Ntrain <- rfNdata[-test,]
Ntest <- rfNdata[test,]

#Run rf model and evaluate performance (36% misclass)
set.seed(9)
rfN <- randomForest(N_TF~.,
    data=Ntrain,mtry=10,maxnodes=5,ntree=400)
rfN

#Test data 75% accuracy (1 of 8 misclassified)
testpred <- predict(rfN,newdata = Ntest)
confusionMatrix(testpred, Ntest$N_TF)

#Partial dependence plots for top variables
varImpPlot(rfN,n.var = 10)

#save(rfN,file="rfN.Rdata")
```

```{r phosphorus random forest model}
#Build Fe dataset
rfPdata <- cbind(P_TF=as.factor(predclass[,'P_TF']),na.roughfix(predclass[,c(2,10:108)]))

#Invert the response variables to put YES limited first
rfPdata$P_TF <- factor(rfPdata$P_TF,levels=c("Yes","No"))

#Test and train subsets
Ptrain <- rfPdata[-test,]
Ptest <- rfPdata[test,]

#Run rf model and evaluate performance
set.seed(7)
rfP <- randomForest(P_TF~.,
    data=Ptrain,mtry=10,maxnodes=3,ntree=1500)
rfP

#Test data 75% accuracy (1 of 8 misclassified)
testpred <- predict(rfP,newdata = Ptest)
confusionMatrix(testpred, Ptest$P_TF)

#Partial dependence plots for top variables
varImpPlot(rfP,n.var = 10)

#save(rfP,file="rfP.Rdata")
```

```{r zinc random forest model}
#Build Zn dataset
rfZndata <- cbind(Zn_TF=as.factor(predclass[,'Zn_TF']),na.roughfix(predclass[,c(2,10:108)]))

#Invert the response variables to put YES limited first
rfZndata$Zn_TF <- factor(rfZndata$Zn_TF,levels=c("Yes","No"))

#Test and train subsets
Zntrain <- rfZndata[-test,]
Zntest <- rfZndata[test,]

#Run rf model and evaluate performance
set.seed(30)
rfZn <- randomForest(Zn_TF~.,
    data=Zntrain,mtry=100,maxnodes=4,ntree=500)
rfZn

#Test data 75% accuracy (1 of 8 misclassified)
testpred <- predict(rfZn,newdata = Zntest)
confusionMatrix(testpred, Zntest$Zn_TF)

#Partial dependence plots for top variables
varImpPlot(rfZn,n.var = 10)

#save(rfZn,file="rfZn.Rdata")
```

